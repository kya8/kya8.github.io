<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on Kya's Blog</title><link>https://kya8.github.io/tags/c/</link><description>Recent content in C on Kya's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 06 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://kya8.github.io/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>不用动态内存分配如何实现opaque struct和PIMPL?</title><link>https://kya8.github.io/p/%E4%B8%8D%E7%94%A8%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0opaque-struct%E5%92%8Cpimpl/</link><pubDate>Fri, 06 Dec 2024 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/%E4%B8%8D%E7%94%A8%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0opaque-struct%E5%92%8Cpimpl/</guid><description>&lt;p>C语言编程中一个常见的practice是将某个struct的definition隐藏, 仅通过指针使用它, 而具体的定义放在一个单独的TU之中,
叫opaque struct. 这种做法的目的一般是为了隐藏struct中的成员, 作为加速编译的隔离手段, 并且还能保证ABI稳定性(因为API只有指针).&lt;/p>
&lt;p>在C++中, 当然也可以用C风格的opaque struct, C++并不阻止你这么做, 但通常的做法是用&lt;strong>PIMPL&lt;/strong>, 方法也是类似的.&lt;/p>
&lt;p>例如, 我们有一个C风格的库&lt;code>libfoo&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// foo.h
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">FooCtx&lt;/span> &lt;span class="n">FooCtx&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">FooCtx&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">foo_create_context&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo_destroy_context&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FooCtx&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">foo_some_function&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FooCtx&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// foo.c
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 包含FooCtx和上述函数的定义
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用者只需要拿着这个&lt;code>FooCtx*&lt;/code>的handle, 不需要关心它内部是什么.&lt;/p>
&lt;h1 id="避免动态内存分配">避免动态内存分配
&lt;/h1>&lt;p>常见的opaque struct或者PIML做法, 免不了动态内存分配, 因为&lt;code>FooCtx&lt;/code>的size在头文件里未知.
有没有什么办法可以绕过这个要求? 作为C/C++程序员, 总是对动态内存分配比较敏感. 有些场景, 比如某些嵌入式平台还没有一般的动态分配可用.&lt;/p>
&lt;p>答案是可以, 其实就是把&lt;code>FooCtx&lt;/code>放在栈上, 用一段栈上的buffer提供存储空间.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define FOO_CTX_SIZE &lt;/span>&lt;span class="cm">/*...*/&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define FOO_CTX_ALIGNMENT &lt;/span>&lt;span class="cm">/*...*/&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">FooCtxStorage&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">alignas&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FOO_CTX_ALIGNMENT&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">FOO_CTX_SIZE&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">FooCtxStorage&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">FooCtx&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">foo_init_storage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FooCtxStorage&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo_finish&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FooCtx&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// cleans up additional resources held by FooCtx, no need to free memory.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">foo_some_function&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FooCtx&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>显然, &lt;code>FooCtxStorage::buf&lt;/code>需要能够装下&lt;code>FooCtx&lt;/code>, 并满足内存对齐要求.
这里用了&lt;code>alignas&lt;/code>, 如果没有C11, 也可以把&lt;code>FooCtxStorage&lt;/code>换成一个union, 加入一个member, 用于确保&lt;code>buf&lt;/code>的对齐.&lt;/p>
&lt;p>&lt;code>foo_init_storage&lt;/code>用于在已有的一段缓存上创建一个&lt;code>FooCtx&lt;/code>, 并且返回所创建对象的指针.
其它函数只接收&lt;code>FooCtx*&lt;/code>作为参数.
&lt;code>foo_finish&lt;/code>用于释放&lt;code>FooCtx&lt;/code>可能管理的资源, 但不需要释放它本身占用的存储, 因为存储是由外部提供.&lt;/p>
&lt;p>这个方法使用时需要先在栈上声明一个&lt;code>FooCtxStorage&lt;/code>(当然实际上放在哪里都行), 然后用一个初始化函数获得创建好的&lt;code>FooCtx*&lt;/code>, 有两个变量, 需要一致.
而且, 如果对象被move, 还需要保持指针和storage对象同步. (当然, 可以提供专门的move/copy函数避免错误)&lt;/p>
&lt;h2 id="编译期确保大小和对齐">编译期确保大小和对齐
&lt;/h2>&lt;p>在对应的&lt;code>foo.c&lt;/code>的TU里, 我们可以用一些静态assert确保&lt;code>FOO_CTX_SIZE&lt;/code>和&lt;code>FOO_CTX_ALIGNMENT&lt;/code>确实符合&lt;code>FooCtx&lt;/code>的定义.&lt;/p>
&lt;h2 id="strict-aliasing">Strict aliasing
&lt;/h2>&lt;p>很遗憾, 实际上这个方法仍然是违反strict aliasing rule的, 因为&lt;code>buf&lt;/code>的实际类型是&lt;code>char&lt;/code>数组, 且永远不会改变, 把一个&lt;code>FooCtx&lt;/code>给&lt;code>memcpy&lt;/code>进去也没用.
&lt;code>foo_init_storage&lt;/code>必定会把&lt;code>buf&lt;/code>这片区域当做&lt;code>FooCtx&lt;/code>来访问, 就算传&lt;code>void*&lt;/code>也没区别, 因此这实际是UB.&lt;/p>
&lt;p>(注意, 用&lt;code>char*&lt;/code>访问&lt;code>FooCtx&lt;/code>可以, 但反过来不行)&lt;/p>
&lt;h1 id="inline-pimpl">Inline PIMPL
&lt;/h1>&lt;p>A.K.A. fast PIMPL, 也就是不需要经过动态内存分配的PIMPL.
原理上和上面的方法类似, 但由于C++提供了&lt;strong>placement new&lt;/strong>和&lt;code>std::launder&lt;/code>, 可以非UB地实现.
(这里假设读者已经知晓PIMPL的一般用法.)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// foo.h
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">Foo&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Foo&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">~&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">noexcept&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 有需要的话, 声明(或delete)copy和move
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 其它method...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="nc">Impl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">static&lt;/span> &lt;span class="k">constexpr&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">impl_alignment&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="cm">/* write it down, or just use max_align_t if no extended alignment */&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">static&lt;/span> &lt;span class="k">constexpr&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">impl_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="cm">/* .. */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">alignas&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">impl_alignment&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">impl_size&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//Impl* handle; //这一项可以不要, 省掉一点空间, 换成下面的函数.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Impl&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">get_impl&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">noexcept&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// foo.cpp中的内容
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">Foo&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Impl&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static_assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">impl_size&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Impl&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static_assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">impl_alignment&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="k">alignof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Impl&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Foo&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果有handle, 就这时候记录它.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// handle = new(buf) Impl{};
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 没有的话, 直接new, 丢掉指针, 一会用std::launder找回来.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="n">Impl&lt;/span>&lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Foo&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Impl&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Foo&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">get_impl&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">noexcept&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">launder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">reinterpret_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Impl&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Foo&lt;/span>&lt;span class="o">::~&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">noexcept&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">get_impl&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">-&amp;gt;~&lt;/span>&lt;span class="n">Impl&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>创建&lt;code>Foo&lt;/code>时, 我们用placement new在静态的&lt;code>buf&lt;/code>上创建&lt;code>Impl&lt;/code>对象. 这样会隐式地结束原本&lt;code>unsigned char&lt;/code>的生命周期,
并开始&lt;code>Impl&lt;/code>对象的生命周期.
placement new返回的指针可以记录着, 以后就可以通过它访问&lt;code>Impl&lt;/code>了.&lt;/p>
&lt;p>但这里为了省掉这个额外的&lt;code>Foo::handle&lt;/code>成员变量, 我们额外定义一个&lt;code>Foo::get_impl()&lt;/code>函数, 帮我们安全地从&lt;code>buf&lt;/code>获取&lt;code>Impl&lt;/code>对象.
这里需要用到&lt;code>std::launder&lt;/code>, 否则从原本的&lt;code>buf&lt;/code>指针直接转换得到的&lt;code>Impl*&lt;/code>指针并不能用于安全地访问新构建的&lt;code>Impl&lt;/code>对象.&lt;/p>
&lt;p>(也就是说, 如果没有&lt;code>std::launder&lt;/code>可用, 就需要用一个成员变量记录placement new产生的指针.)&lt;/p>
&lt;p>析构函数中, 需要我们显式地调用&lt;code>Impl&lt;/code>上的析构函数.&lt;/p>
&lt;h2 id="abi稳定性">ABI稳定性
&lt;/h2>&lt;p>需要注意, 这种做法也部分舍弃了普通PIMPL带来的ABI稳定性的好处, 因为&lt;code>Foo::buf&lt;/code>的大小和对齐可能随着&lt;code>Foo::Impl&lt;/code>变化.&lt;/p>
&lt;p>一种workaround是把&lt;code>impl_alignment&lt;/code>调整得足够大, 并且给&lt;code>impl_size&lt;/code>预留足够的空间, 这样&lt;code>Impl&lt;/code>增长并不总需要改变&lt;code>buf&lt;/code>.
源文件里有&lt;code>static_asset&lt;/code>检查, 所以不用担心大小或对齐不够的情况.&lt;/p></description></item><item><title>Signed与Unsigned整型</title><link>https://kya8.github.io/p/signed%E4%B8%8Eunsigned%E6%95%B4%E5%9E%8B/</link><pubDate>Fri, 02 Aug 2024 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/signed%E4%B8%8Eunsigned%E6%95%B4%E5%9E%8B/</guid><description>&lt;h1 id="signed-or-unsigned">Signed or unsigned?
&lt;/h1>&lt;p>在C与C++编程中的一个经典又经常被误解的问题是, 应当使用signed还是unsigned整数类型? 这个问题很早就有标准答案:&lt;/p>
&lt;ul>
&lt;li>C++核心规范: &lt;a class="link" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#arithmetic" target="_blank" rel="noopener"
>Arithmetic - ES.100 - ES.107&lt;/a>
&lt;blockquote>
&lt;p>You should not use the unsigned integer types such as &lt;code>uint32_t&lt;/code>, unless there is a valid reason such as representing a bit pattern rather than a number, or you need defined overflow modulo $2^N$. &lt;strong>In particular, do not use unsigned types to say a number will never be negative. Instead, use assertions for this&lt;/strong>.&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>&lt;a class="link" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf" target="_blank" rel="noopener"
>Subscripts and sizes should be signed - Bjarne Stroustrup&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>即: 只要是有&lt;strong>算数意义&lt;/strong>的数字, 除非一些例外情况, 都应当使用signed整型. 算数意义是指, 这个数字如果被用于加减乘除等数学运算或者比较大小, 是有意义的.&lt;/p>
&lt;h1 id="理由和例子">理由和例子
&lt;/h1>&lt;h2 id="非负逻辑">非负逻辑
&lt;/h2>&lt;p>&lt;strong>尤其是, 不要用unsigned整型来表示一个数字逻辑上不能是负数.&lt;/strong> 这可能是初学者最常见的错误. 这种情况应该在设计时用contract/pre-condition/post-condition来表示, 并在实现代码内用assert来检查.&lt;/p>
&lt;p>例如, 一个函数的参数需要接收一个带有算数意义的整型, 且逻辑上不能为负数. 如果使用Unsigned整型, 调用者传入负数, 那么实际得到的实参也只会被wrap成一个&lt;strong>无有效意义的&lt;/strong>正数,
此时函数内甚至无法判断调用者是不小心传入了负数, 还是真的mean to传入这个被wrap的正数. 并且这个wrap过程是well-defined, 并不能被ubsan之类的工具抓到.&lt;/p>
&lt;p>关于这一条, 最常见的例子就是数组的下标, offset, 以及数组大小. 但在C与C++标准库, 以及其它的OS原生API中, 基本都是用&lt;code>size_t&lt;/code>来表示.&lt;/p>
&lt;ul>
&lt;li>POSIX规定了&lt;code>ssize_t&lt;/code>, 但这个类型仅仅是用来保证能够返回表示错误的一个sentinel值, 它保证能表示的负数只有-1. (当然, 实际上它一般就是&lt;code>size_t&lt;/code>的signed版本, 即&lt;code>std::make_signed_t&amp;lt;size_t&amp;gt;&lt;/code>).&lt;/li>
&lt;/ul>
&lt;p>C++标准库中的index与size类型为&lt;code>size_t&lt;/code>也可以归为历史遗留问题. 对于自己的代码, 建议使用&lt;code>std::ptrdiff_t&lt;/code>或者&lt;code>gsl::index&lt;/code>.&lt;/p>
&lt;h2 id="混用signed与unsigned">混用signed与unsigned
&lt;/h2>&lt;p>由于C与C++中关于算术操作的类型转换规则, 在算数操作中混用signed和unsigned整型可能会导致一些不直观的后果,
例如最简单的&lt;code>unsigned(1) &amp;lt; int(-1)&lt;/code>.&lt;/p>
&lt;p>至于为什么不用unsigned arithmetics, 理由是unsigned整形的算数规则并不直观(如wrap-around), 容易silently导致错误, 难以发现. 并且缺少负数的算术操作也不方便. 如上一点所说, 这类silent的错误经常无法分辨, 对于溢出类错误(严格说, unsigned整型不存在overflow, 超出范围只有well-defined的wrap-around)尽管不会UB, 但也没有任何帮助, 只会让程序带着错误的数据silently继续运行, 引发不可预测的后果. UB至少还可以用一些工具抓到.&lt;/p>
&lt;h2 id="优化">优化
&lt;/h2>&lt;p>signed整形的overflow是UB, 这一点使得编译器能更好的优化, 例如一些index循环. 关于这一点, 引用Zig的一段介绍:&lt;/p>
&lt;blockquote>
&lt;p>Carefully chosen undefined behavior. For example, in Zig both signed and unsigned integers have undefined behavior on overflow, contrasted to only signed integers in C. This &lt;a class="link" href="https://godbolt.org/z/n_nLEU" target="_blank" rel="noopener"
>facilitates optimizations that are not available in C&lt;/a>.&lt;/p>
&lt;p>- &lt;a class="link" href="https://ziglang.org/learn/overview" target="_blank" rel="noopener"
>ziglang overview&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>当然, 在Release build里, UB的后果不可预测, 因此, 最好用一些额外手段确保安全, 例如使用checked arithmetics, 产生溢出错误就直接abort, 或者逻辑上确保不会出现overflow.&lt;/p>
&lt;p>&lt;strong>无论如何, 用wrap-around的做法逃避算数溢出都不是一个解决方案!&lt;/strong>&lt;/p>
&lt;h2 id="其它">其它
&lt;/h2>&lt;p>对于正常逻辑上非负的数字, 使用signed整形就多出了负数的范围, 可用来作为sentinel值返回错误. 这是十分常见的做法.
至于这种做法本身适不适合(相比于&lt;code>std::optional&lt;/code>等其它方式), 属于另一个问题.&lt;/p>
&lt;h1 id="例外情况">例外情况
&lt;/h1>&lt;p>这些情况下, 可以允许(或必要)使用unsigned&lt;/p>
&lt;h2 id="非算数意义">非算数意义
&lt;/h2>&lt;h3 id="bitbyte-位操作">bit/byte, 位操作
&lt;/h3>&lt;p>众所周知, 如果我们只关心访问一串byte, 此时应该使用&lt;code>unsigned char&lt;/code>来表示字节. 此外, 对于位操作, unsigned整数也更加方便, 例如用于表示一个bit-field.&lt;/p>
&lt;h3 id="其它-1">其它
&lt;/h3>&lt;p>作为一个无算数意义的标记使用. 例如, 一个64位的hash函数一般返回&lt;code>uint64_t&lt;/code>. 还有一些格式里的&lt;code>FOURCC&lt;/code>标记等magic number.
一个随机发生器的原始输出一般也是unsigned, 作为一串随机的bit使用.&lt;/p>
&lt;h2 id="需要额外的1-bit位宽范围--省空间">需要额外的1-bit位宽范围 / 省空间
&lt;/h2>&lt;p>对于32位, 64位的整形, signed整形正数部分少掉的这一位位宽一般不是问题.
但是, 如果我们要表示0-255范围的数字, 那就需要用&lt;code>uint8_t&lt;/code>(不考虑&lt;code>CHAR_BIT &amp;gt; 8&lt;/code>的情况), 否则就需要两倍大小. 这种情况下额外的1-bit位宽就matter了.
8bit图像的表示就是常见的例子, 这里的数值显然是具有算数意义的.&lt;/p>
&lt;h3 id="char--signed-char--unsigned-char">char / signed char / unsigned char
&lt;/h3>&lt;p>注意区分这三个不同的基础类型. &lt;code>unsigned char&lt;/code>表示raw字节. &lt;code>signed char&lt;/code>用于带符号的算数数值. 如上所述, 为了正数位宽也可使用&lt;code>unsigned char&lt;/code>. &lt;code>char&lt;/code>应仅用于字符, 不应依赖它实际是signed还是unsigned.&lt;/p>
&lt;h2 id="需要wrap-aroundmodular逻辑">需要wrap-around/modular逻辑
&lt;/h2>&lt;p>比较少见, 但有时我们事实上确实需要用到wrap-around/modular逻辑&amp;hellip;&lt;/p>
&lt;h2 id="二进制序列化">二进制序列化
&lt;/h2>&lt;p>二进制序列化需要统一的数值二进制表示.
不考虑端序, 对于正整数的表示一般没有异议, 但负整数可能存在差异(尽管也十分少见, 绝大多数平台都是2&amp;rsquo;s complement表示).
因此, 二进制序列化/文件格式中, 对于非负的整数数值一般都是直接使用unsigned表示, 包括定点数的存储. 这样做也可以多出1-bit的正数位宽.&lt;/p>
&lt;h1 id="rust">Rust
&lt;/h1>&lt;p>这些规则大部分并不适用于Rust. Rust中基本的整数类型都适用于算数操作, 可以理解为它们只是具有不同的取值范围, 不允许隐式转换, 并且它们之间的显示转换也是安全的, &lt;em>除了 &lt;code>as&lt;/code>&lt;/em>. 对于不安全的转换以及溢出行为, 可以选择使用wrap-around或者panick.&lt;/p></description></item><item><title>Portable Signal handling</title><link>https://kya8.github.io/p/portable-signal-handling/</link><pubDate>Mon, 20 May 2024 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/portable-signal-handling/</guid><description>&lt;h1 id="stdsignal-and-signal-handlers">&lt;code>std::signal&lt;/code> and signal handlers
&lt;/h1>&lt;p>The standard function &lt;code>std::signal&lt;/code> enables registering &lt;em>signal handlers&lt;/em> that are invoked when a given signal is delivered, asynchronously.
Since the handler can interrupt the execution of the program at potentially any point, actions allowed in the handler are quite limited.
In particular, the handler is allowed to access a global (with static storage duration) variable that is &lt;code>volatile std::sig_atomic_t&lt;/code> or lock-free &lt;code>std::atomic&amp;lt;...&amp;gt;&lt;/code>.
This lets us set a flag inside the handler, and correctly check the flag outside the handler.
Additionally, a signal handler can re-call &lt;code>std::signal&lt;/code> for the same signal that is currently being handled.&lt;/p>
&lt;p>The POSIX standard specifies additional library functions that are guaranteed to be async-signal-safe, that is, safe to call from signal handlers (See &lt;code>man 7 signal-safety&lt;/code>).
However on POSIX systems, the &lt;code>sigaction&lt;/code> family of functions should be preferred.&lt;/p>
&lt;h1 id="portable-ways-to-catch-signals">Portable ways to catch signals
&lt;/h1>&lt;p>Suppose we need to catch a signal and inform the program about it, so it can act accordingly. E.g., catching &lt;code>SIGINT&lt;/code> (&lt;code>Ctrl-C&lt;/code>) to perform graceful cleanup and shutdown.
The canonical way of doing this is to have a dedicated thread that responds to a global flag, which shall be set by the signal handler.&lt;/p>
&lt;p>Before C++20, there&amp;rsquo;s no platform-independent way, besides polling the flag repeatedly:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nb">false&lt;/span>&lt;span class="p">};&lt;/span> &lt;span class="c1">// assuming it&amp;#39;s lock-free
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">extern&lt;/span> &lt;span class="s">&amp;#34;C&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">signal_handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">sig&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">sig&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">SIGINT&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">store&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">sigint_thread_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="cm">/*...*/&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// demonstration only
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">load&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">this_thread&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">sleep_for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">milliseconds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// precede to perform shutdown actions ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// e.g., signaling the main thread to stop.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&amp;hellip;Because we don&amp;rsquo;t have a signal-safe function to wait on the atomic flag.&lt;/p>
&lt;h2 id="stdatomictwait">&lt;code>std::atomic&amp;lt;T&amp;gt;::wait()&lt;/code>
&lt;/h2>&lt;p>C++20 introduces &lt;code>wait()&lt;/code> and &lt;code>notify()&lt;/code> methods on &lt;code>std::atomic&amp;lt;T&amp;gt;&lt;/code> and &lt;code>std::atomic_flag&lt;/code>.
If the atomic type is lock-free (which is always the case for &lt;code>std::atomic_flag&lt;/code>),
we can safely use &lt;code>wait()&lt;/code> and &lt;code>notify()&lt;/code> in the waiting thread and the signal handler, to avoid the sleep-and-poll loop above.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic_flag&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">{};&lt;/span> &lt;span class="c1">// Always lock-free
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// C++20 guarantees it&amp;#39;s initialized to false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">extern&lt;/span> &lt;span class="s">&amp;#34;C&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">signal_handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">sig&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">sig&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">SIGINT&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">test_and_set&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">sigint_thread_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="cm">/*...*/&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">false&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// will block until flag has been changed.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="platform-dependent-ways">Platform-dependent ways
&lt;/h1>&lt;h2 id="posix">POSIX
&lt;/h2>&lt;p>Incrementing a POSIX semaphore (&lt;code>sem_post&lt;/code>) is signal-safe according to the POSIX specification.
This can be used for notification in signal handlers. The waiting thread would wait via &lt;code>sem_wait&lt;/code>.&lt;/p>
&lt;p>Alternatively there is &lt;code>sigwaitinfo&lt;/code> and &lt;code>sigwait&lt;/code>, which explicitly wait for pending signals.&lt;/p>
&lt;p>If you&amp;rsquo;re on Linux, another alternative would be using &lt;code>signalfd&lt;/code> and waiting on the file descriptor (e.g. via &lt;code>epoll&lt;/code>).&lt;/p>
&lt;h2 id="windows">Windows
&lt;/h2></description></item><item><title>Pointers (again)</title><link>https://kya8.github.io/p/pointers-again/</link><pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/pointers-again/</guid><description>&lt;h1 id="pointer-arithmetics">Pointer arithmetics
&lt;/h1>&lt;p>It is well-known that in both C and C++, pointer arithmetics is only meaningful for operands (and the imaginary resultant pointer address) that are related to each other.
By related we mean, they both point to the same object (or one-past-end), or the same array (or one-past-end).&lt;/p>
&lt;p>Per C++ standard, pointers are &lt;em>iterators&lt;/em>, not &lt;em>numbers representing address space&lt;/em>, although they&amp;rsquo;re often implemented as such.&lt;/p>
&lt;p>To quote &lt;a class="link" href="https://stackoverflow.com/a/56038995/17815599" target="_blank" rel="noopener"
>https://stackoverflow.com/a/56038995/17815599&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>Speaking more academically: &lt;strong>pointers are not numbers&lt;/strong>. They are pointers.&lt;/p>
&lt;p>It is true that a pointer on your system is implemented as a numerical representation of an address-like representation of a location in some abstract kind of memory (probably a virtual, per-process memory space).&lt;/p>
&lt;p>But C++ doesn&amp;rsquo;t care about that. C++ wants you to think of pointers as post-its, as bookmarks, to specific objects. The numerical address values are just a side-effect. The &lt;em>only&lt;/em> arithmetic that makes sense on a pointer is &lt;em>forwards and backwards&lt;/em> through an array of objects; nothing else is philosophically meaningful.&lt;/p>&lt;/blockquote>
&lt;p>So, &lt;code>p1 - p0&lt;/code> isn&amp;rsquo;t really saying &amp;ldquo;give me the difference between the addresses pointed by &lt;code>p1&lt;/code> and &lt;code>p0&lt;/code>&amp;rdquo;,
it&amp;rsquo;s saying &amp;ldquo;Assuming they both refer to objects in the same array, what&amp;rsquo;s the difference between their indices inside the array?&amp;rdquo;
(Here, we consider a single object as an array of length one). If the assumption does not hold, this is undefined behavior.
For relational (greater than, less than&amp;hellip;) comparisons however, the behavior is &lt;em>unspecified&lt;/em>.&lt;/p>
&lt;h2 id="what-are-arrays">what are &amp;ldquo;arrays&amp;rdquo;?
&lt;/h2>&lt;p>It covers a bit wider than normal (i.e. &lt;code>int arr[]&lt;/code>) arrays.
In particular, pointer returned by &lt;code>malloc&lt;/code> can be addressed as arrays.&lt;/p>
&lt;p>Also see &lt;a class="link" href="https://stackoverflow.com/questions/47830449/can-you-do-arithmetic-on-a-char-pointing-at-another-object" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/47830449/can-you-do-arithmetic-on-a-char-pointing-at-another-object&lt;/a> for aliasing &lt;code>char*&lt;/code> pointers.&lt;/p>
&lt;h2 id="pointer-to-struct-member">pointer to struct member
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">xyz_s&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">z&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">xyz_s&lt;/span> &lt;span class="n">pt&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">auto&lt;/span> &lt;span class="n">px&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">pt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">auto&lt;/span> &lt;span class="n">py&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">px&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1">// ???
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>xyz&lt;/code> is standard-layout type, which means it has C-like memory layout. However in this example, &lt;em>even if the struct &lt;code>xyz_s&lt;/code> does not contain any paddings&lt;/em>, &lt;code>py&lt;/code> does not actually point to &lt;code>pt.y&lt;/code>. It points to &amp;ldquo;one-past-end&amp;rdquo; of &lt;code>pt.x&lt;/code>!
That&amp;rsquo;s because there&amp;rsquo;re no arrays here, so &lt;code>py&lt;/code> can only be the &amp;ldquo;one-past-end&amp;rdquo; pointer of &lt;code>pt.x&lt;/code>. Although evaluating &lt;code>px+1&lt;/code> is well-defined, dereferencing the resultant &lt;code>py&lt;/code> is UB. It&amp;rsquo;s not &lt;code>pt.y&lt;/code>!&lt;/p>
&lt;p>If we change &lt;code>xyz_s&lt;/code> to contain an array of 3 floats, that kind of pointer arithmetic is okay. Also absence of padding in array is guaranteed.&lt;/p>
&lt;h3 id="padding">Padding
&lt;/h3>&lt;p>Actually, the compiler is free to insert paddings inside a struct in an implementation-defined way, &lt;strong>except at the beginning&lt;/strong> of a struct. There&amp;rsquo;s nothing in the standard mandating no paddings in &lt;code>xyz_s&lt;/code>!&lt;/p>
&lt;p>This is also why there&amp;rsquo;s no guaranteed size for &lt;code>std::array&amp;lt;T, N&amp;gt;&lt;/code>. Even if it only contains a single member &lt;code>T data_[N]&lt;/code>, the compiler can still insert paddings after it.&lt;/p>
&lt;h2 id="pointer-in-nested-arrays">pointer in nested arrays
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">Pt3&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">xyz&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">xyz_s&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">auto&lt;/span> &lt;span class="n">p0x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">xyz&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">auto&lt;/span> &lt;span class="n">p0z&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p0x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// okay
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="n">p1x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p0z&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// bad
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Here, &lt;code>p1x&lt;/code> is still one-past-end of &lt;code>vec[0].xyz[2]&lt;/code>. Because, there&amp;rsquo;s no array of type &lt;code>float&lt;/code> and length &lt;code>N*3&lt;/code>! And consider possible paddings mentioned above.&lt;/p>
&lt;h1 id="pointer-to-first-member-of-standard-layout-struct">Pointer to first member of (standard layout) struct
&lt;/h1>&lt;p>(By &amp;ldquo;first&amp;rdquo; we mean the first declared member)&lt;/p>
&lt;p>Ref: &lt;a class="link" href="https://en.cppreference.com/w/cpp/language/static_cast#Pointer-interconvertible_objects" target="_blank" rel="noopener"
>https://en.cppreference.com/w/cpp/language/static_cast#Pointer-interconvertible_objects&lt;/a>&lt;/p>
&lt;p>Two objects a and b are &lt;em>pointer-interconvertible&lt;/em> if:&lt;/p>
&lt;ul>
&lt;li>they are the same object, or&lt;/li>
&lt;li>one is a union object and the other is a non-static data member of that object, or&lt;/li>
&lt;li>one is a standard-layout class object and the other is the first non-static data member of that object or any base class subobject of that object, or&lt;/li>
&lt;li>there exists an object c such that a and c are pointer-interconvertible, and c and b are pointer-interconvertible.&lt;/li>
&lt;/ul>
&lt;p>&amp;hellip;combined with pointer conversion rules, it&amp;rsquo;s possible to convert between pointer to a standard-layout struct and pointer to its first member, via an intermediate &lt;code>void*&lt;/code> pointer.&lt;/p>
&lt;h1 id="pointer-total-order">Pointer total order
&lt;/h1>&lt;p>There is actually one exception to the &amp;ldquo;same-object-or-array&amp;rdquo; rule: the total order of pointers in C++.
It only applies to comparison functors, &lt;code>std::less&lt;/code>, &lt;code>std::greater&lt;/code> etc. This total order is consistent with defined pointer comparison rules of the built-in comparison operators.
For the unspecified case, the result becomes implementation-defined.&lt;/p>
&lt;p>Note that in C, relational comparison of unrelated pointers is &lt;em>undefined&lt;/em>.&lt;/p></description></item></channel></rss>