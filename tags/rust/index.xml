<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on Kya's Blog</title><link>https://kya8.github.io/tags/rust/</link><description>Recent content in Rust on Kya's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 28 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://kya8.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Non-destructive move, null object and class invariants</title><link>https://kya8.github.io/p/non-destructive-move-null-object-and-class-invariants/</link><pubDate>Fri, 29 Sep 2023 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/non-destructive-move-null-object-and-class-invariants/</guid><description>&lt;h1 id="class-invariant">Class invariant
&lt;/h1>&lt;p>A class invariant is a condition that always holds true for any object of the class, throughout its lifetime.
Typical class invariants include consistency of some internal state, or that a resource-owning class always acquires and manages some resource.&lt;/p>
&lt;p>Proper designing and maintaining of class invariants provides useful guarantees for users (and implementers) that lowers our mental burdens.&lt;/p>
&lt;h2 id="enforcing-class-invariant-at-construction">Enforcing class invariant at construction
&lt;/h2>&lt;p>The canonical way is to throw in the constructor, if it fails to establish the required invariants. Alternatively we could force the use of a factory constructor, which returns &lt;code>std::optional&amp;lt;T&amp;gt;&lt;/code> or similar.&lt;/p>
&lt;h2 id="default-constructed-zombie-object">Default-constructed, zombie object
&lt;/h2>&lt;p>Sometimes, we&amp;rsquo;re left with an &lt;em>valid&lt;/em> object that fails to meet some condition, e.g. a resource owning class object that hasn&amp;rsquo;t acquired any resources. Such zombie objects are rather common in C++ codebases. For example, if a class invariant requires some argument to construct, a default constructor of the class, if defined, will create a zombie object.&lt;/p>
&lt;p>In many situations, we&amp;rsquo;re forced to make our class default-constructible (e.g. resizing &lt;code>std::vector&lt;/code>)&lt;/p>
&lt;p>A zombie (or null, nil) object is not broken, it just introduces an additional null state, which adds some responsibility/contract of checking the object state on the user (and sometimes on the implementer).&lt;/p>
&lt;h1 id="move-compromises-class-invariant">Move compromises class invariant
&lt;/h1>&lt;p>For a resource owning class, according to &lt;em>the Rule of 0-3-5&lt;/em>, we could define custom move constructor and assignment operator for it, which shall transfer resource ownership. However, this requires compromising the class invariant that it always holds a resource, since the moved-from object must have been emptied, and marked as null. A zombie object is leaked by move! This is a price we pay for non-destructive move in C++.&lt;/p>
&lt;p>Still, such &lt;em>weak&lt;/em> invariant is better than no invariant at all. We could further weaken the invariant by defining public, non-throwing (default) constructors that create zombie objects.&lt;/p>
&lt;p>If only move produces zombie objects, we just tell the user not to use moved-from objects of our class, which is not a big deal, and on our side we only need to do additional checking when releasing the resource (to prevent potential double-free, etc.).&lt;/p>
&lt;h2 id="non-destructive-move">Non-destructive move
&lt;/h2>&lt;p>In C++, moving from an object has nothing to do with its lifetime. It&amp;rsquo;s just a plain function invoked on the rvalue-referenced rhs object, nothing special.&lt;/p>
&lt;p>Although the move function can do basically anything, in practice we want it to transfer owned resources, which leaves the moved-from object emptied. And when the object gets out of scope, its destructor gets called, which checks for null and finds it is already emptied.&lt;/p>
&lt;p>This operation might leave the moved-from object in a null state, but does not terminate its lifetime, thus compromising class invariants. The root of all evil!&lt;/p>
&lt;p>Some languages, e.g. Rust has &lt;strong>destructive moves&lt;/strong>. In Rust, a moved from object is no longer valid, and you get a compile-time error if trying to access them afterwards. This way, moving won&amp;rsquo;t affect class invariants, since it terminates the object&amp;rsquo;s lifetime.&lt;/p>
&lt;p>The implementation of move semantics in Rust is not much different (it could simply be a memcpy). The magic is language support such that moved-from objects are no longer valid, not the move itself. Also the destructor of the moved-from object will NOT be called, since it is indeed moved, so the responsibility of freeing is transferred away. Compare to C++, a moved-from variable is still there, and can be used as normal, so its destructor still needs to be called when its lifetime actually ends (which means the destructor should check for null).&lt;/p>
&lt;p>In all, moved-from objects in C++ are (usually meant to be) null objects, while in Rust, moved-from objects are &amp;hellip;., &lt;strong>absence&lt;/strong> of objects!&lt;/p>
&lt;h1 id="sum-types-for-null">Sum-types for null
&lt;/h1>&lt;p>We&amp;rsquo;ve talked about zombie/null objects, which embed a special internal state of null (or not).&lt;/p>
&lt;p>If the class invariant that the object cannot be null always holds, we should lift the null state indication out of the object: If the class invariant fails to establish, then there shouldn&amp;rsquo;t be an object at all!&lt;/p>
&lt;p>It&amp;rsquo;s basically going from zombie/null object vs. non-null object, to invariant-holding object vs. &lt;strong>the absence of object&lt;/strong>. The latter can be cleanly represented by sum types, such as &lt;code>Optional&lt;/code>, &lt;code>Result&lt;/code> in Rust, and &lt;code>std::optional&lt;/code>, &lt;code>std::expected&lt;/code> in C++.&lt;/p></description></item></channel></rss>