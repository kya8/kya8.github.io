<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Macos on Kya's Blog</title><link>https://kya8.github.io/tags/macos/</link><description>Recent content in Macos on Kya's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 26 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://kya8.github.io/tags/macos/index.xml" rel="self" type="application/rss+xml"/><item><title>交叉编译到macOS</title><link>https://kya8.github.io/p/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%88%B0macos/</link><pubDate>Sun, 26 Oct 2025 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%88%B0macos/</guid><description>&lt;p&gt;对于CI/CD系统, 或者本地的开发/测试而言, 为每个编译的Target系统准备一台机器或虚拟机显然有些繁琐. 最好, 我们能在一台机器上进行对多平台的交叉编译.
不过, 对于macOS目标, 目前网上的已有经验并不多.&lt;/p&gt;
&lt;h1 id="osxcross"&gt;osxcross
&lt;/h1&gt;&lt;p&gt;大部分人搜索&amp;quot;cross compiling to macos&amp;quot;应该就会找到&lt;a class="link" href="https://github.com/tpoechtrager/osxcross" target="_blank" rel="noopener"
&gt;osxcross&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;众所周知, 交叉编译需要&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为target平台生成代码的编译器和工具链&lt;/li&gt;
&lt;li&gt;target平台的一套SDK, 即头文件和一些基础库.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;osxcross&lt;/code&gt;这个项目默认干了什么事呢?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译&lt;code&gt;cctools-port&lt;/code&gt;, 这是一个把Apple的&lt;code&gt;ar&lt;/code&gt;, &lt;code&gt;ld,&lt;/code&gt;, &lt;code&gt;otool&lt;/code&gt;, &lt;code&gt;lipo&lt;/code&gt;等工具链binary移植到了其他Unices的项目.&lt;/li&gt;
&lt;li&gt;帮你获取并解包macOS的SDK. 其中, 会帮你编译&lt;code&gt;xar&lt;/code&gt;, &lt;code&gt;pbzx&lt;/code&gt;等若干工具.&lt;/li&gt;
&lt;li&gt;至于最重要的编译器部分, 默认只是生成了一些wrapper, 调用你host系统上的Clang. 众所周知, Clang自己就自带交叉编译功能, 因此不需要额外编译一个不同target的cc.
&lt;ul&gt;
&lt;li&gt;你也可以选择从头编译Clang或GCC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很简单吧! 其实弄懂原理后, 可以不需要&lt;code&gt;osxcross&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;PS: &lt;code&gt;osxcross&lt;/code&gt;仍然有一些小bug, 比如编译出的&lt;code&gt;ld&lt;/code&gt;还依赖一个内部库, 需要你&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;一下, 比如一些wrapper脚本里变量设置的有问题.&lt;/p&gt;
&lt;h1 id="自己动手"&gt;自己动手
&lt;/h1&gt;&lt;h2 id="获取macos-sdk"&gt;获取macOS SDK
&lt;/h2&gt;&lt;p&gt;先去Apple Developer官网直接下载Command Line Tools, 得到一个dmg文件, 如&lt;code&gt;Command_Line_Tools_for_Xcode_26.2.dmg&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;然后, 需要准备几个工具软件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;7z (p7zip或者新版的7zip)&lt;/li&gt;
&lt;li&gt;xar (一般发行版官方都有打包)&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://github.com/NiklasRosenstein/pbzx.git" target="_blank" rel="noopener"
&gt;pbzx&lt;/a&gt;, 另见我提的&lt;a class="link" href="https://github.com/NiklasRosenstein/pbzx/pull/9" target="_blank" rel="noopener"
&gt;修复Linux上编译的PR&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来解压:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;7z e -so Command_Line_Tools_for_Xcode_26.2.dmg &lt;span class="s2"&gt;&amp;#34;Command Line Developer Tools/Command Line Tools*.pkg&amp;#34;&lt;/span&gt; &amp;gt; &lt;span class="s2"&gt;&amp;#34;Command Line Tools.pkg&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;mkdir pkg_data out
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;xar -xf &lt;span class="s2"&gt;&amp;#34;Command Line Tools.pkg&amp;#34;&lt;/span&gt; -C pkg_data
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt; PKG in pkg_data/*.pkg&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; pbzx -n &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;PKG&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/Payload&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; out &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; cpio -i&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;解压完后, 就能在&lt;code&gt;out/Library/Developer/CommandLineTools/SDKs/&lt;/code&gt;下面看到SDK的根目录了, 如&lt;code&gt;MacOSX15.4.sdk&lt;/code&gt;. (下载的dmg版本不同, 具体位置可能不同). 其中含有头文件和基础库等.&lt;/p&gt;
&lt;h2 id="配置clang"&gt;配置Clang
&lt;/h2&gt;&lt;p&gt;这里就十分简单了. 只要你主机上的Clang/LLVM功能完整, 能够输出macOS的target.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;clang --target&lt;span class="o"&gt;=&lt;/span&gt;arm64-apple-darwin24.4 --sysroot&lt;span class="o"&gt;=&lt;/span&gt;/path/to/SDKs/MacOSX15.4.sdk -fuse-ld&lt;span class="o"&gt;=&lt;/span&gt;lld test.c -o &lt;span class="nb"&gt;test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其实就是设置一下target和sysroot. 另外linker需要用lld, 因为我们host上的GNU ld并不支持其它target.&lt;/p&gt;
&lt;h3 id="universal-binary"&gt;Universal binary
&lt;/h3&gt;&lt;p&gt;如果要编译Universal binary, 加入&lt;code&gt;-arch arm64 -arch x86_64&lt;/code&gt;即可.
当然, 也可以分别编译后, 用&lt;code&gt;lipo&lt;/code&gt;合并.&lt;/p&gt;
&lt;h2 id="其它工具链软件"&gt;其它工具链软件
&lt;/h2&gt;&lt;p&gt;我们还需要Apple的其它工具链软件, 也就是&lt;code&gt;cctools-port&lt;/code&gt;部分. 事实上, 我们用LLVM的工具链基本能完全替代:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;otool&lt;/code&gt; -&amp;gt; &lt;code&gt;llvm-otool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ar&lt;/code&gt; -&amp;gt; &lt;code&gt;llvm-ar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strip&lt;/code&gt; -&amp;gt; &lt;code&gt;llvm-strip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lipo&lt;/code&gt; -&amp;gt; &lt;code&gt;llvm-lipo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LLVM工具链和Clang前端一样, 都原生支持交叉编译, 支持各平台的二进制格式.&lt;/p&gt;
&lt;h2 id="cmake"&gt;CMake
&lt;/h2&gt;&lt;p&gt;上面的配置足够编译一些简单的程序了. 对于CMake, 设置一些CMake的标准变量即可, 例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-D CMAKE_CXX_COMPILER=clang
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-D CMAKE_CXX_COMPILER_TARGET=arm64-apple-darwin24.4
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-D CMAKE_LINKER_TYPE=LLD
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-D CMAKE_SYSROOT=/path/to/SDKs/MacOSX15.4.sdk
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-D CMAKE_OSX_DEPLOYMENT_TARGET=15.0 # 最低兼容的macOS版本
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此外, 还有交叉编译应当设置的标准变量, 如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-D CMAKE_SYSTEM_NAME=Darwin
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-D CMAKE_SYSTEM_PROCESSOR=arm64
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当然, 也可以把它们放进一个CMake toolchain文件.&lt;/p&gt;
&lt;h2 id="windows主机"&gt;Windows主机?
&lt;/h2&gt;&lt;p&gt;Windows主机上用法也是一样简单, 获取SDK内容后, 去&lt;a class="link" href="https://github.com/llvm/llvm-project/releases/latest" target="_blank" rel="noopener"
&gt;LLVM github&lt;/a&gt;直接下载安装Windows安装包. 记得把安装目录(bin)加到PATH里.&lt;/p&gt;
&lt;p&gt;然后你就有了Windows上完整可用的Clang前端和LLVM工具链, 支持所有target平台. (其实这就是在Windows上使用Clang编译程序的最简单方法: 去官网直接下载安装LLVM安装包! 不是什么clang-cl或者MinGW Clang)&lt;/p&gt;
&lt;p&gt;安装好的Clang默认是编译Windows原生程序, 并链接到MS的C/C++运行库.
与上面相同, 我们只要指定&lt;code&gt;--target&lt;/code&gt;和&lt;code&gt;--sysroot&lt;/code&gt;就能编译macOS程序了.&lt;/p&gt;
&lt;h1 id="总结"&gt;总结
&lt;/h1&gt;&lt;p&gt;由于工程中产生了交叉编译到macOS的需求, 花了半天时间研究, 但最终的方法其实非常简单明晰. 实际上Clang/LLVM承担了主要的heavy-lifting, 我们只需要获取到目标平台的SDK即可.&lt;/p&gt;
&lt;h1 id="bonus-编译到windows"&gt;Bonus: 编译到Windows
&lt;/h1&gt;&lt;p&gt;有了上述的经验, 很自然地, 我们会想到用类似的方法编译到Windows原生程序.
一直以来, 交叉编译到Windows最成熟, 也最常见的方案就是MinGW. 不过, MinGW的做法是自己提供了一套Windows API的SDK, 并且不能使用MSVC的C++ STL.&lt;/p&gt;
&lt;p&gt;实际上, 交叉编译到Windows也只需要Clang/LLVM 加上 Windows的SDK. 后者需要我们自己去下载(需要同意MS的协议).
不过, 已经有人做了这个工作: &lt;a class="link" href="https://github.com/Jake-Shadle/xwin" target="_blank" rel="noopener"
&gt;xwin&lt;/a&gt; &lt;a class="link" href="https://github.com/rust-cross/cargo-xwin" target="_blank" rel="noopener"
&gt;cargo-xwin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个项目是用于编译Rust到${arch}-pc-windows-msvc这些target, 实际上就是帮你自动下载Windows SDK, 并且修复一些目录/大小写问题, 然后你就可以直接使用了.
用法就是:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;clang++ -target x86_64-pc-windows-msvc -fuse-ld&lt;span class="o"&gt;=&lt;/span&gt;lld-link -I xwin/splat/crt/include -I xwin/splat/sdk/include/ucrt -I xwin/splat/sdk/include/um -I xwin/splat/sdk/include/shared -L xwin/splat/crt/lib/x86_64 -L xwin/splat/sdk/lib/um/x86_64 -L xwin/splat/sdk/lib/ucrt/x86_64 hello.cpp -o hello.exe
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(或者也可以用clang-cl)&lt;/p&gt;</description></item></channel></rss>