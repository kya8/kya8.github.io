<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Systems Programming on Kya's Blog</title><link>https://kya8.github.io/tags/systems-programming/</link><description>Recent content in Systems Programming on Kya's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 20 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://kya8.github.io/tags/systems-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Portable Signal handling</title><link>https://kya8.github.io/p/portable-signal-handling/</link><pubDate>Mon, 20 May 2024 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/portable-signal-handling/</guid><description>&lt;h1 id="stdsignal-and-signal-handlers">&lt;code>std::signal&lt;/code> and signal handlers
&lt;/h1>&lt;p>The standard function &lt;code>std::signal&lt;/code> enables registering &lt;em>signal handlers&lt;/em> that are invoked when a given signal is delivered, asynchronously.
Since the handler can interrupt the execution of the program at potentially any point, actions allowed in the handler are quite limited.
In particular, the handler is allowed to access a global (with static storage duration) variable that is &lt;code>volatile std::sig_atomic_t&lt;/code> or lock-free &lt;code>std::atomic&amp;lt;...&amp;gt;&lt;/code>.
This lets us set a flag inside the handler, and correctly check the flag outside the handler.
Additionally, a signal handler can re-call &lt;code>std::signal&lt;/code> for the same signal that is currently being handled.&lt;/p>
&lt;p>The POSIX standard specifies additional library functions that are guaranteed to be async-signal-safe, that is, safe to call from signal handlers (See &lt;code>man 7 signal-safety&lt;/code>).
However on POSIX systems, the &lt;code>sigaction&lt;/code> family of functions should be preferred.&lt;/p>
&lt;h1 id="portable-ways-to-catch-signals">Portable ways to catch signals
&lt;/h1>&lt;p>Suppose we need to catch a signal and inform the program about it, so it can act accordingly. E.g., catching &lt;code>SIGINT&lt;/code> (&lt;code>Ctrl-C&lt;/code>) to perform graceful cleanup and shutdown.
The canonical way of doing this is to have a dedicated thread that responds to a global flag, which shall be set by the signal handler.&lt;/p>
&lt;p>Before C++20, there&amp;rsquo;s no platform-independent way, besides polling the flag repeatedly:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nb">false&lt;/span>&lt;span class="p">};&lt;/span> &lt;span class="c1">// assuming it&amp;#39;s lock-free
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">extern&lt;/span> &lt;span class="s">&amp;#34;C&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">signal_handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">sig&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">sig&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">SIGINT&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">store&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">sigint_thread_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="cm">/*...*/&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// demonstration only
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">load&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">this_thread&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">sleep_for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">milliseconds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// precede to perform shutdown actions ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// e.g., signaling the main thread to stop.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&amp;hellip;Because we don&amp;rsquo;t have a signal-safe function to wait on the atomic flag.&lt;/p>
&lt;h2 id="stdatomictwait">&lt;code>std::atomic&amp;lt;T&amp;gt;::wait()&lt;/code>
&lt;/h2>&lt;p>C++20 introduces &lt;code>wait()&lt;/code> and &lt;code>notify()&lt;/code> methods on &lt;code>std::atomic&amp;lt;T&amp;gt;&lt;/code> and &lt;code>std::atomic_flag&lt;/code>.
If the atomic type is lock-free (which is always the case for &lt;code>std::atomic_flag&lt;/code>),
we can safely use &lt;code>wait()&lt;/code> and &lt;code>notify()&lt;/code> in the waiting thread and the signal handler, to avoid the sleep-and-poll loop above.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic_flag&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">{};&lt;/span> &lt;span class="c1">// Always lock-free
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// C++20 guarantees it&amp;#39;s initialized to false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">extern&lt;/span> &lt;span class="s">&amp;#34;C&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">signal_handler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">sig&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">sig&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">SIGINT&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">test_and_set&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">sigint_thread_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="cm">/*...*/&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">false&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// will block until flag has been changed.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="platform-dependent-ways">Platform-dependent ways
&lt;/h1>&lt;h2 id="posix">POSIX
&lt;/h2>&lt;p>Incrementing a POSIX semaphore (&lt;code>sem_post&lt;/code>) is signal-safe according to the POSIX specification.
This can be used for notification in signal handlers. The waiting thread would wait via &lt;code>sem_wait&lt;/code>.&lt;/p>
&lt;p>Alternatively there is &lt;code>sigwaitinfo&lt;/code> and &lt;code>sigwait&lt;/code>, which explicitly wait for pending signals.&lt;/p>
&lt;p>If you&amp;rsquo;re on Linux, another alternative would be using &lt;code>signalfd&lt;/code> and waiting on the file descriptor (e.g. via &lt;code>epoll&lt;/code>).&lt;/p>
&lt;h2 id="windows">Windows
&lt;/h2></description></item><item><title>Fork(2) and the OOM killer</title><link>https://kya8.github.io/p/fork2-and-the-oom-killer/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/fork2-and-the-oom-killer/</guid><description>&lt;h1 id="the-fork2-syscall">The &lt;code>fork(2)&lt;/code> syscall
&lt;/h1>&lt;p>This is one of the identifying features of a Unix-like operating system. &lt;code>fork(2)&lt;/code> has existed since the first version of Unix back in the days of PDP-11.
It creates a new process by simply duplicates the entire address space of the calling process, after which point they run indenpendently.&lt;/p>
&lt;p>&lt;code>fork&lt;/code>+&lt;code>exec&lt;/code> is the standard way to create a child process in Unix, although it has an obvious problem: The parent process will have its entire process space copied,
only to spawn a new process that has little regard for any of it. In fact, this is what the First Edition Unix did.&lt;/p>
&lt;h2 id="the-virtual-memory-story">The virtual memory story
&lt;/h2>&lt;p>Overtime, people got smart and started implementing Copy-On-Write for &lt;code>fork&lt;/code>, so it din&amp;rsquo;t need to actually copy that much pages. In the case of &lt;code>fork&lt;/code>+&lt;code>exec&lt;/code>, no extra
segments will be copied. This is the most prominent reason for defending &lt;code>fork&lt;/code>: The OS only copies when needed! Nothing is wasted.&lt;/p>
&lt;p>Indeed, the CoW approach did solve some of &lt;code>fork&lt;/code>&amp;rsquo;s problems, but not all. In particular, The file descriptor inhertance from &lt;code>fork&lt;/code> isn&amp;rsquo;t nice to play with, and has lead to many hacks (such as &lt;code>CLOEXEC&lt;/code>).
Not only that, this model has implicitly lead to memory overcommittment and the OOM killer on Linux, which IMO is one of the most glaring design failures on Linux.&lt;/p>
&lt;h1 id="the-oom-killer">The OOM killer
&lt;/h1>&lt;p>Support we have 8G of memory in total, and some process has taken-up 6G of it (e.g., by &lt;code>malloc&lt;/code> and &lt;code>memset&lt;/code>). Now this process calls &lt;code>fork&lt;/code> to create a new child process.
We all know that will not fail on Linux. What if the calling process merely wants to &lt;code>fork&lt;/code> and &lt;code>exec&lt;/code> a new process? The 2G remaining memory is more than enough for it.
After all, it is the obvious point for CoW implementations of &lt;code>fork&lt;/code> which we all agree upon.&lt;/p>
&lt;p>There&amp;rsquo;s no way for the OS to know how the child process will be used after &lt;code>fork&lt;/code>. It may exec a tiny program and exit immediately, or it might &lt;strong>actually&lt;/strong> fiddle with all the &amp;ldquo;copied&amp;rdquo; data.
The CoW implementation is reponsible for keeping this transparent, so everyone is happy. That is, until the child process starts modifying more than 2G of memory and get killed by OOM!&lt;/p>
&lt;p>By CoW &lt;code>fork&lt;/code> and overcommittment, the Linux kernel essentially lies to the child process that it has allocated 6G of memory, while effectively it can write to only 2G of it (given the parent process does not release its memory).
The child is free to use that 6G of memory however it wants, but there&amp;rsquo;s no guarantee it won&amp;rsquo;t exhaust all available memory and get killed. Maybe the parent process will release its hold of memory at some point,
so the lie is covered up. Who knows! Most user-land processes, might get killed by OOM, essentially at any point, because the kernel lies to user-land processes about memory reservations.&lt;/p>
&lt;p>There are some other examples of memory overcommittment, e.g. &lt;code>malloc&lt;/code>, but that is a different story.&lt;/p>
&lt;h1 id="alternatives">Alternatives
&lt;/h1>&lt;h2 id="vfork-and-clone">vfork and clone
&lt;/h2>&lt;p>The &lt;code>vfork&lt;/code> syscall was an early alternative to &lt;code>fork&lt;/code>, first appearing on BSD. It&amp;rsquo;s essentially a restricted version of &lt;code>fork&lt;/code>.&lt;/p>
&lt;p>A more functional alternative would be &lt;code>clone&lt;/code> on Linux. From &lt;code>man 2 clone&lt;/code>:&lt;/p>
&lt;blockquote>
&lt;p>By contrast with fork(2), these system calls provide more precise control over what pieces of execution context are shared between the calling process and the child process&amp;hellip;&lt;/p>&lt;/blockquote>
&lt;h2 id="spawn">spawn
&lt;/h2>&lt;p>The obvious solution is the &lt;em>spawn&lt;/em> model, where a new process is constructed from a clean state. The user only opts in for some inheritance or shared state, so it has none of the flaws of fork.&lt;/p>
&lt;p>A somewhat failed attemp is &lt;code>posix_spawn&lt;/code> defined by POSIX standard. Essentially no one uses it since it&amp;rsquo;s far too cumbersome.&lt;/p>
&lt;p>If implemented correctly, spawn should be preferable to &lt;code>fork&lt;/code> in most cases.
The &lt;code>fork&lt;/code> model &lt;em>&lt;strong>can&lt;/strong>&lt;/em> be genuinely useful in some contexts, however most of time people just &lt;code>fork&lt;/code> and &lt;code>exec&lt;/code> to create child processes, which gave birth to its shortcomings.&lt;/p></description></item></channel></rss>