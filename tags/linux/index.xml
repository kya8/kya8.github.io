<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on Kya's Blog</title><link>https://kya8.github.io/tags/linux/</link><description>Recent content in Linux on Kya's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 16 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://kya8.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Fork(2) and the OOM killer</title><link>https://kya8.github.io/p/fork2-and-the-oom-killer/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/fork2-and-the-oom-killer/</guid><description>&lt;h1 id="the-fork2-syscall"&gt;The &lt;code&gt;fork(2)&lt;/code&gt; syscall
&lt;/h1&gt;&lt;p&gt;This is one of the identifying features of a Unix-like operating system. &lt;code&gt;fork(2)&lt;/code&gt; has existed since the first version of Unix back in the days of PDP-11.
It creates a new process by simply duplicates the entire address space of the calling process, after which point they run indenpendently.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fork&lt;/code&gt;+&lt;code&gt;exec&lt;/code&gt; is the standard way to create a child process in Unix, although it has an obvious problem: The parent process will have its entire process space copied,
only to spawn a new process that has little regard for any of it. In fact, this is what the First Edition Unix did.&lt;/p&gt;
&lt;h2 id="the-virtual-memory-story"&gt;The virtual memory story
&lt;/h2&gt;&lt;p&gt;Overtime, people got smart and started implementing Copy-On-Write for &lt;code&gt;fork&lt;/code&gt;, so it din&amp;rsquo;t need to actually copy that much pages. In the case of &lt;code&gt;fork&lt;/code&gt;+&lt;code&gt;exec&lt;/code&gt;, no extra
segments will be copied. This is the most prominent reason for defending &lt;code&gt;fork&lt;/code&gt;: The OS only copies when needed! Nothing is wasted.&lt;/p&gt;
&lt;p&gt;Indeed, the CoW approach did solve some of &lt;code&gt;fork&lt;/code&gt;&amp;rsquo;s problems, but not all. In particular, The file descriptor inhertance from &lt;code&gt;fork&lt;/code&gt; isn&amp;rsquo;t nice to play with, and has lead to many hacks (such as &lt;code&gt;CLOEXEC&lt;/code&gt;).
Not only that, this model has implicitly lead to memory overcommittment and the OOM killer on Linux, which IMO is one of the most glaring design failures on Linux.&lt;/p&gt;
&lt;h1 id="the-oom-killer"&gt;The OOM killer
&lt;/h1&gt;&lt;p&gt;Support we have 8G of memory in total, and some process has taken-up 6G of it (e.g., by &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;memset&lt;/code&gt;). Now this process calls &lt;code&gt;fork&lt;/code&gt; to create a new child process.
We all know that will not fail on Linux. What if the calling process merely wants to &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; a new process? The 2G remaining memory is more than enough for it.
After all, it is the obvious point for CoW implementations of &lt;code&gt;fork&lt;/code&gt; which we all agree upon.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s no way for the OS to know how the child process will be used after &lt;code&gt;fork&lt;/code&gt;. It may exec a tiny program and exit immediately, or it might &lt;strong&gt;actually&lt;/strong&gt; fiddle with all the &amp;ldquo;copied&amp;rdquo; data.
The CoW implementation is reponsible for keeping this transparent, so everyone is happy. That is, until the child process starts modifying more than 2G of memory and get killed by OOM!&lt;/p&gt;
&lt;p&gt;By CoW &lt;code&gt;fork&lt;/code&gt; and overcommittment, the Linux kernel essentially lies to the child process that it has allocated 6G of memory, while effectively it can write to only 2G of it (given the parent process does not release its memory).
The child is free to use that 6G of memory however it wants, but there&amp;rsquo;s no guarantee it won&amp;rsquo;t exhaust all available memory and get killed. Maybe the parent process will release its hold of memory at some point,
so the lie is covered up. Who knows! Most user-land processes, might get killed by OOM, essentially at any point, because the kernel lies to user-land processes about memory reservations.&lt;/p&gt;
&lt;p&gt;There are some other examples of memory overcommittment, e.g. &lt;code&gt;malloc&lt;/code&gt;, but that is a different story.&lt;/p&gt;
&lt;h1 id="alternatives"&gt;Alternatives
&lt;/h1&gt;&lt;h2 id="vfork-and-clone"&gt;vfork and clone
&lt;/h2&gt;&lt;p&gt;The &lt;code&gt;vfork&lt;/code&gt; syscall was an early alternative to &lt;code&gt;fork&lt;/code&gt;, first appearing on BSD. It&amp;rsquo;s essentially a restricted version of &lt;code&gt;fork&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A more functional alternative would be &lt;code&gt;clone&lt;/code&gt; on Linux. From &lt;code&gt;man 2 clone&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By contrast with fork(2), these system calls provide more precise control over what pieces of execution context are shared between the calling process and the child process&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="spawn"&gt;spawn
&lt;/h2&gt;&lt;p&gt;The obvious solution is the &lt;em&gt;spawn&lt;/em&gt; model, where a new process is constructed from a clean state. The user only opts in for some inheritance or shared state, so it has none of the flaws of fork.&lt;/p&gt;
&lt;p&gt;A somewhat failed attemp is &lt;code&gt;posix_spawn&lt;/code&gt; defined by POSIX standard. Essentially no one uses it since it&amp;rsquo;s far too cumbersome.&lt;/p&gt;
&lt;p&gt;If implemented correctly, spawn should be preferable to &lt;code&gt;fork&lt;/code&gt; in most cases.
The &lt;code&gt;fork&lt;/code&gt; model &lt;em&gt;&lt;strong&gt;can&lt;/strong&gt;&lt;/em&gt; be genuinely useful in some contexts, however most of time people just &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; to create child processes, which gave birth to its shortcomings.&lt;/p&gt;</description></item></channel></rss>