<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on Kya's Blog</title><link>https://kya8.github.io/categories/linux/</link><description>Recent content in Linux on Kya's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 06 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://kya8.github.io/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Qemu Windows客户机最佳实践</title><link>https://kya8.github.io/p/qemu-windows%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Tue, 12 Mar 2024 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/qemu-windows%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>&lt;p&gt;(这只是一个记录贴. 最近又需要在Linux机器上弄一台Windows开发虚拟机, 遂翻出了几年前的记录, 并针对较新的Qemu版本做了一些更新.)&lt;/p&gt;
&lt;h1 id="tldr"&gt;TL;DR
&lt;/h1&gt;&lt;p&gt;Qemu命令行参数:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;qemu-system-x86_64 -accel kvm -machine q35 -name windows &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-cpu host,hv_relaxed,hv_spinlocks&lt;span class="o"&gt;=&lt;/span&gt;0x1fff,hv_vapic,hv_vpindex,hv_synic,hv_time,hv_stimer,hv_tlbflush,hv_tlbflush_ext,hv_ipi,hv_stimer_direct,hv_runtime,hv_frequencies,hv_reenlightenment,hv_avic,hv_xmm_input,hv_evmcs &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-smp &lt;span class="nv"&gt;sockets&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1,cores&lt;span class="o"&gt;=&lt;/span&gt;8,threads&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-m 8G &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-rtc &lt;span class="nv"&gt;base&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;localtime &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-drive &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;pflash,format&lt;span class="o"&gt;=&lt;/span&gt;raw,readonly&lt;span class="o"&gt;=&lt;/span&gt;on,file&lt;span class="o"&gt;=&lt;/span&gt;OVMF_CODE.fd -drive &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;pflash,format&lt;span class="o"&gt;=&lt;/span&gt;raw,file&lt;span class="o"&gt;=&lt;/span&gt;OVMF_VARS.fd &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-device virtio-balloon &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-vga none -device virtio-vga &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# qxl: -device qxl-vga,xres=1920,yres=1080,vgamem_mb=32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-audiodev pipewire,id&lt;span class="o"&gt;=&lt;/span&gt;snd0 -device ich9-intel-hda -device hda-output,audiodev&lt;span class="o"&gt;=&lt;/span&gt;snd0 &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-device qemu-xhci,id&lt;span class="o"&gt;=&lt;/span&gt;xhci -device usb-tablet &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-drive &lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;disk0.qcow2,if&lt;span class="o"&gt;=&lt;/span&gt;virtio,discard&lt;span class="o"&gt;=&lt;/span&gt;unmap &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-nic user,model&lt;span class="o"&gt;=&lt;/span&gt;virtio-net-pci,guestfwd&lt;span class="o"&gt;=&lt;/span&gt;tcp::1080-tcp:127.0.0.1:1080 &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# virtiofs share&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-object memory-backend-memfd,id&lt;span class="o"&gt;=&lt;/span&gt;mem,size&lt;span class="o"&gt;=&lt;/span&gt;8G,share&lt;span class="o"&gt;=&lt;/span&gt;on -numa node,memdev&lt;span class="o"&gt;=&lt;/span&gt;mem -chardev socket,id&lt;span class="o"&gt;=&lt;/span&gt;char0,path&lt;span class="o"&gt;=&lt;/span&gt;/tmp/vm-share -device vhost-user-fs-pci,chardev&lt;span class="o"&gt;=&lt;/span&gt;char0,tag&lt;span class="o"&gt;=&lt;/span&gt;my-share &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# For installing Windows&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-drive &lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;windows.iso,index&lt;span class="o"&gt;=&lt;/span&gt;2,media&lt;span class="o"&gt;=&lt;/span&gt;cdrom &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-drive &lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;virtio-win.iso,index&lt;span class="o"&gt;=&lt;/span&gt;3,media&lt;span class="o"&gt;=&lt;/span&gt;cdrom
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Virtiofsd:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;/usr/libexec/virtiofsd --socket-path&lt;span class="o"&gt;=&lt;/span&gt;/tmp/virtiofs-share.sock --shared-dir /path/to/shared/dir
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id="关于qemu命令行"&gt;关于Qemu命令行
&lt;/h1&gt;&lt;p&gt;推荐阅读: &lt;a class="link" href="https://archive.fosdem.org/2018/schedule/event/vai_qemu_jungle/" target="_blank" rel="noopener"
&gt;https://archive.fosdem.org/2018/schedule/event/vai_qemu_jungle/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Qemu的一些选项经常让新手困惑, 主要原因其实就是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Qemu模拟的每个虚拟设备都由host backend和guest device两部分组成. 两部分一般用一个名字(id)相联系.
诸如&lt;code&gt;-nic&lt;/code&gt;, &lt;code&gt;-drive&lt;/code&gt;之类的选项只是为了便利提供的shortcut, 能够同时配置两部分.&lt;/p&gt;
&lt;p&gt;例如, &lt;code&gt;-nic user,model=virtio-net-pci&lt;/code&gt;的完整写法是&lt;code&gt;--device virtio-net-pci,netdev=n1 --netdev user,id=n1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qemu的一个system emulator一般会有一些默认模拟的设备, 即使不加任何命令行参数都会被模拟. 例如, x86的system emulator默认会模拟一个vga显卡等.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="参数说明"&gt;参数说明
&lt;/h1&gt;&lt;h2 id="芯片组和cpu"&gt;芯片组和CPU
&lt;/h2&gt;&lt;p&gt;x86-64上一般使用q35机型即可.
&lt;code&gt;-cpu host&lt;/code&gt;表示使用主机的CPU型号, 并且会开启对应的指令集支持. 后面的一串&lt;code&gt;hv_*&lt;/code&gt;是hyper-v enlightments, 适用于Windows客户机.&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;-smp&lt;/code&gt;选项可指定CPU的拓扑关系, 这里指定一枚CPU, 8个核心, 每个核心有1个线程.&lt;/p&gt;
&lt;h2 id="uefi固件"&gt;UEFI固件
&lt;/h2&gt;&lt;p&gt;利用OVMF提供的edk2固件, 实现UEFI启动. 一般发行版都会打包OVMF固件, 没有的话可以从网上下载.
固件分为只读和可写两部分, 以&lt;code&gt;pflash&lt;/code&gt;形式添加.&lt;/p&gt;
&lt;h2 id="显卡"&gt;显卡
&lt;/h2&gt;&lt;p&gt;Qemu给x86客机默认模拟的是一个基本的VGA设备, 足以用于Windows客机显示.
除此之外可选的是&lt;code&gt;virtio-vga&lt;/code&gt;和&lt;code&gt;qxl-vga&lt;/code&gt;. 前者可选择OpenGL加速(基于API转发, 目前对Windows无效), 后者主要用于给SPICE远程连接.&lt;/p&gt;
&lt;p&gt;它们都是兼容VGA的, 在virtio驱动iso里包含对应的驱动. 这些Windows驱动都是DoD(Display only driver)驱动, 没有Windows上的图形加速功能, 用处不大, 功能上和基本的VGA无异.&lt;/p&gt;
&lt;p&gt;参看: &lt;a class="link" href="https://www.kraxel.org/blog/2019/09/display-devices-in-qemu/" target="_blank" rel="noopener"
&gt;https://www.kraxel.org/blog/2019/09/display-devices-in-qemu/&lt;/a&gt; (很有价值的blog, 来自qemu开发者)&lt;/p&gt;
&lt;p&gt;(如果要求图形性能, 还是需要GPU直通或GPU虚拟化, 目前Qemu中没有虚拟显卡能给Windows客机提供较好的图形加速.
不过, 我们的目的仅是一个Windows开发机, 普通的VGA显示已足够.)&lt;/p&gt;
&lt;h2 id="声音"&gt;声音
&lt;/h2&gt;&lt;p&gt;主机Backend部分上面选择了pipewire. 此外也可以用pulseaudio等. &lt;code&gt;-device ich9-intel-hda -device hda-output,audiodev=snd0&lt;/code&gt;添加了两个客机设备, 分别是audio controller和audio codec, 和前面的backend id对应.&lt;/p&gt;
&lt;h2 id="usb-输入"&gt;USB, 输入
&lt;/h2&gt;&lt;p&gt;一些芯片组(包括q35)具有自带的USB支持, 可用&lt;code&gt;-usb&lt;/code&gt;开启.
但这里我们选择了&lt;code&gt;qemu-xhci&lt;/code&gt;, qemu实现的一个通用的USB 3.0总线设备.&lt;/p&gt;
&lt;p&gt;鼠标输入采用&lt;code&gt;usb-tablet&lt;/code&gt;.
tablet设备的用处类似于触摸屏, 即Qemu无需grab input, 鼠标划过Qemu显示窗口时, 就自动输入到客机桌面中.&lt;/p&gt;
&lt;p&gt;键盘方面, Qemu的x86 system emulator会默认模拟, 不需要手动添加.&lt;/p&gt;
&lt;h2 id="存储"&gt;存储
&lt;/h2&gt;&lt;p&gt;直接使用一块virtio-scsi硬盘: &lt;code&gt;-drive file=disk0.qcow2,if=virtio,discard=unmap&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if=virtio&lt;/code&gt;在较早版本的Qemu上应该是&lt;code&gt;virtio-blk&lt;/code&gt;驱动.
新版本的Qemu里则默认是&lt;code&gt;virtio-scsi&lt;/code&gt;总线上的scsi硬盘, 相当于:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-drive if=none,id=hd1,format=qcow2,file=disk0.qcow2,discard=unmap
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-device scsi-hd,drive=hd1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;qcow2硬盘镜像可用&lt;code&gt;qemu-img&lt;/code&gt;自行创建.&lt;/p&gt;
&lt;h3 id="trim"&gt;TRIM
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;virtio-scsi&lt;/code&gt;以及&lt;code&gt;virtio-blk&lt;/code&gt;存储设备均支持TRIM指令(即scsi标准中的unmap), 可用&lt;code&gt;discard=unmap&lt;/code&gt;开启.
通过这种方式, 客机能直接告知主机, 存储中的哪些部分已经不再使用, 可以释放.
在这之前, 常见的老办法是在客机内写入一个全部为0的大文件, 直到把硬盘填满, 再把这个文件删除,
此时硬盘上的空闲空间应该全部是0, 随后将主机上的镜像文件转为稀疏文件.&lt;/p&gt;
&lt;p&gt;对于不同的主机存储backend, 收到来自客机的TRIM指令后的处理方式也不同.
对于qcow2和raw镜像文件, Qemu的处理方式是给文件中被trim的空闲部分punch hole, 使之成为稀疏文件, 从而减少镜像文件的实际硬盘占用.
这一点可用&lt;code&gt;ls -lhs&lt;/code&gt;或&lt;code&gt;du disk0.qcow2 ; du --apparent-size disk0.qcow2&lt;/code&gt;来验证.&lt;/p&gt;
&lt;p&gt;Windows客机在删除文件时会自动trim.
也可以使用自带的硬盘优化工具给硬盘手动trim, 其中虚拟硬盘会被显示为&amp;quot;Thin provisioned drive&amp;quot;.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://kya8.github.io/p/qemu-windows%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/windows-trim.png"
width="704"
height="507"
srcset="https://kya8.github.io/p/qemu-windows%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/windows-trim_hu_98411f8a2bcbc196.png 480w, https://kya8.github.io/p/qemu-windows%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/windows-trim_hu_77f73b88c8caf96a.png 1024w"
loading="lazy"
alt="Windows硬盘优化工具显示"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="333px"
&gt;&lt;/p&gt;
&lt;h3 id="安装盘"&gt;安装盘
&lt;/h3&gt;&lt;p&gt;安装时, 我们需要以cdrom形式添加windows的安装iso, 以及包含virtio windows驱动的iso.
安装过程中, 需要先加载virtio存储驱动, 才能看到硬盘并继续安装.&lt;/p&gt;
&lt;h2 id="网络"&gt;网络
&lt;/h2&gt;&lt;p&gt;如果在意网络性能, 最好是使用一个由主机上的一个虚拟interface back的tap设备.
简便起见, 这里使用了qemu自带的user-mode networking, 作为主机backend.
客机设备则是virtio网卡, 需要安装对应驱动.&lt;/p&gt;
&lt;p&gt;user-mode networking自带了端口转发功能, 两个方向均可. 上面的配置是把客机发向虚拟内网中主机(网关)&lt;code&gt;1080&lt;/code&gt;端口的tcp包转发到本机的&lt;code&gt;127.0.0.1:1080&lt;/code&gt;处.&lt;/p&gt;
&lt;h2 id="virtiofs文件共享"&gt;virtiofs文件共享
&lt;/h2&gt;&lt;p&gt;目前Qemu上性能最好的共享文件方案就是virtiofs, 它是基于共享内存实现, 性能远高于9pfs或者其它基于网络层的方案.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客机部分: Windows上的virtiofs文件系统驱动是用WinFsp实现, 这个相当于Windows上的FUSE, 需要在客机提前安装好.
此外, 需要安装好virtiofs的客机驱动和服务. 这部分可以直接安装virtio驱动iso中的guest工具包.
安装后在services.msc中找到并开启virtiofs服务即可.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机部分: 运行virtiofsd, 指定通讯用socket路径和共享文件路径即可;
在对应的Qemu参数中, 配置好共享内存和socket, 并添加&lt;code&gt;vhost-user-fs-pci&lt;/code&gt;设备.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="其它"&gt;其它
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-rtc base=localtime&lt;/code&gt;: 由于Windows默认认为硬件时钟是本地时区. 因此将模拟的硬件时钟设为本地时区. (假设客户机的时区和本机相同)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-device virtio-balloon&lt;/code&gt;: ballon设备帮助qemu主进程释放客户机空闲的内存.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="结果"&gt;结果
&lt;/h1&gt;&lt;p&gt;&lt;img src="https://kya8.github.io/p/qemu-windows%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/qemu-win11.png"
width="2052"
height="1266"
srcset="https://kya8.github.io/p/qemu-windows%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/qemu-win11_hu_8dc0d9f33ff836d0.png 480w, https://kya8.github.io/p/qemu-windows%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/qemu-win11_hu_dbd81f4e6fc0a974.png 1024w"
loading="lazy"
alt="运行Windows 11"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="389px"
&gt;&lt;/p&gt;</description></item><item><title>Fork(2) and the OOM killer</title><link>https://kya8.github.io/p/fork2-and-the-oom-killer/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/fork2-and-the-oom-killer/</guid><description>&lt;h1 id="the-fork2-syscall"&gt;The &lt;code&gt;fork(2)&lt;/code&gt; syscall
&lt;/h1&gt;&lt;p&gt;This is one of the identifying features of a Unix-like operating system. &lt;code&gt;fork(2)&lt;/code&gt; has existed since the first version of Unix back in the days of PDP-11.
It creates a new process by simply duplicates the entire address space of the calling process, after which point they run indenpendently.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fork&lt;/code&gt;+&lt;code&gt;exec&lt;/code&gt; is the standard way to create a child process in Unix, although it has an obvious problem: The parent process will have its entire process space copied,
only to spawn a new process that has little regard for any of it. In fact, this is what the First Edition Unix did.&lt;/p&gt;
&lt;h2 id="the-virtual-memory-story"&gt;The virtual memory story
&lt;/h2&gt;&lt;p&gt;Overtime, people got smart and started implementing Copy-On-Write for &lt;code&gt;fork&lt;/code&gt;, so it din&amp;rsquo;t need to actually copy that much pages. In the case of &lt;code&gt;fork&lt;/code&gt;+&lt;code&gt;exec&lt;/code&gt;, no extra
segments will be copied. This is the most prominent reason for defending &lt;code&gt;fork&lt;/code&gt;: The OS only copies when needed! Nothing is wasted.&lt;/p&gt;
&lt;p&gt;Indeed, the CoW approach did solve some of &lt;code&gt;fork&lt;/code&gt;&amp;rsquo;s problems, but not all. In particular, The file descriptor inhertance from &lt;code&gt;fork&lt;/code&gt; isn&amp;rsquo;t nice to play with, and has lead to many hacks (such as &lt;code&gt;CLOEXEC&lt;/code&gt;).
Not only that, this model has implicitly lead to memory overcommittment and the OOM killer on Linux, which IMO is one of the most glaring design failures on Linux.&lt;/p&gt;
&lt;h1 id="the-oom-killer"&gt;The OOM killer
&lt;/h1&gt;&lt;p&gt;Support we have 8G of memory in total, and some process has taken-up 6G of it (e.g., by &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;memset&lt;/code&gt;). Now this process calls &lt;code&gt;fork&lt;/code&gt; to create a new child process.
We all know that will not fail on Linux. What if the calling process merely wants to &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; a new process? The 2G remaining memory is more than enough for it.
After all, it is the obvious point for CoW implementations of &lt;code&gt;fork&lt;/code&gt; which we all agree upon.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s no way for the OS to know how the child process will be used after &lt;code&gt;fork&lt;/code&gt;. It may exec a tiny program and exit immediately, or it might &lt;strong&gt;actually&lt;/strong&gt; fiddle with all the &amp;ldquo;copied&amp;rdquo; data.
The CoW implementation is reponsible for keeping this transparent, so everyone is happy. That is, until the child process starts modifying more than 2G of memory and get killed by OOM!&lt;/p&gt;
&lt;p&gt;By CoW &lt;code&gt;fork&lt;/code&gt; and overcommittment, the Linux kernel essentially lies to the child process that it has allocated 6G of memory, while effectively it can write to only 2G of it (given the parent process does not release its memory).
The child is free to use that 6G of memory however it wants, but there&amp;rsquo;s no guarantee it won&amp;rsquo;t exhaust all available memory and get killed. Maybe the parent process will release its hold of memory at some point,
so the lie is covered up. Who knows! Most user-land processes, might get killed by OOM, essentially at any point, because the kernel lies to user-land processes about memory reservations.&lt;/p&gt;
&lt;p&gt;There are some other examples of memory overcommittment, e.g. &lt;code&gt;malloc&lt;/code&gt;, but that is a different story.&lt;/p&gt;
&lt;h1 id="alternatives"&gt;Alternatives
&lt;/h1&gt;&lt;h2 id="vfork-and-clone"&gt;vfork and clone
&lt;/h2&gt;&lt;p&gt;The &lt;code&gt;vfork&lt;/code&gt; syscall was an early alternative to &lt;code&gt;fork&lt;/code&gt;, first appearing on BSD. It&amp;rsquo;s essentially a restricted version of &lt;code&gt;fork&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A more functional alternative would be &lt;code&gt;clone&lt;/code&gt; on Linux. From &lt;code&gt;man 2 clone&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By contrast with fork(2), these system calls provide more precise control over what pieces of execution context are shared between the calling process and the child process&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="spawn"&gt;spawn
&lt;/h2&gt;&lt;p&gt;The obvious solution is the &lt;em&gt;spawn&lt;/em&gt; model, where a new process is constructed from a clean state. The user only opts in for some inheritance or shared state, so it has none of the flaws of fork.&lt;/p&gt;
&lt;p&gt;A somewhat failed attemp is &lt;code&gt;posix_spawn&lt;/code&gt; defined by POSIX standard. Essentially no one uses it since it&amp;rsquo;s far too cumbersome.&lt;/p&gt;
&lt;p&gt;If implemented correctly, spawn should be preferable to &lt;code&gt;fork&lt;/code&gt; in most cases.
The &lt;code&gt;fork&lt;/code&gt; model &lt;em&gt;&lt;strong&gt;can&lt;/strong&gt;&lt;/em&gt; be genuinely useful in some contexts, however most of time people just &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; to create child processes, which gave birth to its shortcomings.&lt;/p&gt;</description></item><item><title>Emulating ARM on QEMU, with UEFI</title><link>https://kya8.github.io/p/emulating-arm-on-qemu-with-uefi/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://kya8.github.io/p/emulating-arm-on-qemu-with-uefi/</guid><description>&lt;p&gt;Emulating ARM machines on QEMU hasn&amp;rsquo;t been straight-forward due to lack of a
standardized way to configure the bootloader across different ARM boards. One
had to extract the kernel image, and specify the boot options on the command
line (&lt;code&gt;-kernel&lt;/code&gt;, &lt;code&gt;-initrd&lt;/code&gt;), so QEMU knows what to do with its machine-specific
boot code.&lt;/p&gt;
&lt;p&gt;We can make things easier with the help of UEFI (namely EDK2, with ARM support), so
installing and booting Linux just works like on a x86 PC target.&lt;/p&gt;
&lt;h1 id="prerequisites"&gt;Prerequisites
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;QEMU system emulator for ARM.&lt;/li&gt;
&lt;li&gt;EDK2 binaries for ARM. They can be extracted from the debian package
&lt;code&gt;qemu-efi-arm&lt;/code&gt; or &lt;code&gt;qemu-efi-aarch64&lt;/code&gt;, depending on your target arch.&lt;/li&gt;
&lt;li&gt;Official Debian installer iso for ARM.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="booting-the-installer"&gt;Booting the installer
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; This example is for arm32&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;First of all, create a new disk image via &lt;code&gt;qemu-img&lt;/code&gt;. Copy EDK2 FW binaries
(&lt;code&gt;AAVMF32_CODE.fd&lt;/code&gt; and &lt;code&gt;AAVMF32_VARS.fd&lt;/code&gt;, the latter is for hosting volatile
variables) and the installer image to the same directory.&lt;/p&gt;
&lt;p&gt;We will be emulating the &lt;code&gt;virt&lt;/code&gt; board, which has support for virtio devices.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;qemu-system-arm -M virt -m 512M -cpu cortex-a15 -smp 4 \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-device qemu-xhci -device usb-kbd \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-device usb-storage,drive=install -blockdev file,filename=debian-testing-armhf-DVD-1.iso,node-name=install \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-blockdev qcow2,node-name=root,file.driver=file,file.filename=disk0.qcow2 -device virtio-blk-device,drive=root \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-nic user,model=virtio \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-pflash ./AAVMF32_CODE.fd -pflash ./AAVMF32_VARS.fd \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-device ramfb
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;The system is given 512M of RAM and 4 cpus
(depending on your QEMU version, this could mean either 4 sockets or 4 cores),
the CPU capability is set to &lt;code&gt;cortex-a15&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-device qemu-xhci -device usb-kbd&lt;/code&gt; attaches a low-overhead USB XHCI bus, and
a USB keyboard. You could add a mouse if needed.
Alternatively, on-board USB support that comes with &lt;code&gt;virt&lt;/code&gt; is available by passing &lt;code&gt;-usb&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Next two lines attach the installer iso as a USB storage device, and the
rootfs disk as a virtio block device.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-nic user,model=virtio&lt;/code&gt; enables basic user-mode networking, backed by the
virtio NIC.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-device ramfb&lt;/code&gt; adds a simple display device, which is just a frambuffer in
guest memory. QEMU ARM system emulator does not emulate a display device by
default. The standard &lt;code&gt;std&lt;/code&gt; VGA won&amp;rsquo;t work since the installer environment
lacks required DRM kmods.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The graphics &amp;amp; input part can be left-out (with &lt;code&gt;-nographic&lt;/code&gt;),
in which case the installer will be presented on the serial console.&lt;/p&gt;
&lt;p&gt;The guest will now boot into the installer iso. Simply
follow the installation instructions, the grub-efi bootloader will be installed to the EFI firmware automatically.&lt;/p&gt;
&lt;h1 id="booting-the-installed-system"&gt;Booting the installed system
&lt;/h1&gt;&lt;p&gt;No additional configuration is required.
Don&amp;rsquo;t forget to attach the UEFI firmware via &lt;code&gt;-pflash&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;qemu-system-arm -M virt -m 512M -cpu cortex-a15 -smp 4 \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-device qemu-xhci -device usb-kbd \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-blockdev qcow2,node-name=root,file.driver=file,file.filename=disk0.qcow2 -device virtio-blk-device,drive=root \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-nic user,model=virtio,hostfwd=tcp::2345-:22 \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-pflash ./AAVMF32_CODE.fd -pflash ./AAVMF32_VARS.fd \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-device VGA
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-virtfs local,path=/host/path/to/shared/,id=share,mount_tag=share,security_model=mapped
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;There are a few additional configurations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Host porting forwarding is enabled for host port 2345, to guest port 22.
This way we are able to ssh directly into the guest system.&lt;/li&gt;
&lt;li&gt;Attach a shared folder to the guest, backed by &lt;code&gt;9pfs&lt;/code&gt;.
The folder can be mounted in the guest via &lt;code&gt;mount -t 9p -o trans=virtio share /path/to/mount&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://kya8.github.io/p/emulating-arm-on-qemu-with-uefi/qemu-arm.png"
width="1154"
height="954"
srcset="https://kya8.github.io/p/emulating-arm-on-qemu-with-uefi/qemu-arm_hu_65440fef599dd3ca.png 480w, https://kya8.github.io/p/emulating-arm-on-qemu-with-uefi/qemu-arm_hu_5737c38876d4b0c7.png 1024w"
loading="lazy"
alt="booted system"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="290px"
&gt;&lt;/p&gt;
&lt;p&gt;Voilà! Your new virtual ARM system is ready to go!&lt;/p&gt;</description></item></channel></rss>