<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Type erasure Type erasure is a generic concept in progamming, where different types can be hidden behind a single, generic interface. You probably already did type erasure in C: passing void* pointer around and casting them! This is a simple case of type erasure, which is not type safe. A tagged union also counts, although it only provides erasure for a pre-defined set of types.\nstd::function std::function<R(Args...)> is a type-erased polymorphic function object that can wrap all kinds of callables with the specified argument types Args... and a return type that is convertible to R. It stores the provided callable (with ownership) by (forwarding) copy/move. Dynamic allocation is required in the general case, however implementations may use SBO (Small Buffer optimization).\n"><title>Type erasure in C++</title><link rel=canonical href=https://kya8.github.io/p/type-erasure-in-c-/><link rel=stylesheet href=/scss/style.min.95d2cc3c53057e0ce2ff257d4913db2ead814a3b31c640724a5fdf4f8d5a6298.css><meta property='og:title' content="Type erasure in C++"><meta property='og:description' content="Type erasure Type erasure is a generic concept in progamming, where different types can be hidden behind a single, generic interface. You probably already did type erasure in C: passing void* pointer around and casting them! This is a simple case of type erasure, which is not type safe. A tagged union also counts, although it only provides erasure for a pre-defined set of types.\nstd::function std::function<R(Args...)> is a type-erased polymorphic function object that can wrap all kinds of callables with the specified argument types Args... and a return type that is convertible to R. It stores the provided callable (with ownership) by (forwarding) copy/move. Dynamic allocation is required in the general case, however implementations may use SBO (Small Buffer optimization).\n"><meta property='og:url' content='https://kya8.github.io/p/type-erasure-in-c-/'><meta property='og:site_name' content="Kya's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='c++'><meta property='article:published_time' content='2023-07-11T00:00:00+00:00'><meta property='article:modified_time' content='2023-12-26T00:00:00+00:00'><meta name=twitter:title content="Type erasure in C++"><meta name=twitter:description content="Type erasure Type erasure is a generic concept in progamming, where different types can be hidden behind a single, generic interface. You probably already did type erasure in C: passing void* pointer around and casting them! This is a simple case of type erasure, which is not type safe. A tagged union also counts, although it only provides erasure for a pre-defined set of types.\nstd::function std::function<R(Args...)> is a type-erased polymorphic function object that can wrap all kinds of callables with the specified argument types Args... and a return type that is convertible to R. It stores the provided callable (with ownership) by (forwarding) copy/move. Dynamic allocation is required in the general case, however implementations may use SBO (Small Buffer optimization).\n"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><div class=site-meta><h1 class=site-name><a href=/>Kya's Blog</a></h1><h2 class=site-description>Place where I post random stuff</h2></div></header><ol class=menu-social><li><a href=https://github.com/kya8 target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#type-erasure>Type erasure</a></li><li><a href=#stdfunction>std::function</a><ol><li><a href=#implementation>Implementation</a></li><li><a href=#performance>Performance</a></li><li><a href=#ownership>Ownership</a></li></ol></li><li><a href=#stdany><code>std::any</code></a></li><li><a href=#stdshared_ptr><code>std::shared_ptr</code></a></li><li><a href=#stdvariant><code>std::variant</code></a><ol><li><a href=#visitation>Visitation</a><ol><li><a href=#implementation-1>Implementation</a></li></ol></li></ol></li><li><a href=#other-sum-types>Other sum types</a></li><li><a href=#type-erased-iterator>Type-erased iterator</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/programming/ style=background-color:#2a9d8f;color:#fff>Programming</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/type-erasure-in-c-/>Type erasure in C++</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jul 11, 2023</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>6 minute read</time></div></footer></div></header><section class=article-content><h1 id=type-erasure>Type erasure</h1><p>Type erasure is a generic concept in progamming, where different types can be hidden behind a single, generic interface.
You probably already did type erasure in C: passing <code>void*</code> pointer around and casting them!
This is a simple case of type erasure, which is not type safe. A tagged union also counts, although it only provides erasure for a pre-defined set of types.</p><h1 id=stdfunction>std::function</h1><p><code>std::function&lt;R(Args...)></code> is a type-erased polymorphic function object that can wrap all kinds of callables with the specified argument types <code>Args...</code> and a return type that is convertible to <code>R</code>.
It stores the provided callable (with ownership) by (forwarding) copy/move. Dynamic allocation is required in the general case, however implementations may use SBO (Small Buffer optimization).</p><p>It&rsquo;s suitable for use at API boundaries, e.g. when providing a callback, with owning/by-value semantics.</p><h2 id=implementation>Implementation</h2><p>The actual type erasure happens inside the constructor. Besides storing the callable type-erased (either by dynamic allocation or SBO), <code>std::function</code> needs to record information about how to
do <code>operator()</code> later. Since <code>std::function</code> is copyable, it also needs to remember how to copy the callable!</p><p>There&rsquo;s even more: If SBO is in effect, to move an <code>std::function</code> would require invoking the callable&rsquo;s move constructor. Otherwise we just move the pointer.</p><p>All of these has to be done inside the constructor of <code>std::function</code> since the type information of the callable is only available there.
Here&rsquo;s a limited implementation I wrote. It has no SBO, and doesn&rsquo;t support all kinds of callables (e.g. member function pointers):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Ptrs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span><span class=p>(</span><span class=o>*</span><span class=n>deleter_ptr</span><span class=p>)(</span><span class=kt>void</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>copy_ptr</span><span class=p>)(</span><span class=kt>void</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TypePointers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=k>static</span> <span class=n>Ptrs</span> <span class=n>ptrs</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>[](</span><span class=kt>void</span><span class=o>*</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>delete</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>[](</span><span class=kt>void</span><span class=o>*</span> <span class=n>p</span><span class=p>)</span><span class=o>-&gt;</span><span class=kt>void</span><span class=o>*</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>new</span> <span class=n>T</span><span class=p>{</span> <span class=o>*</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Func</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>R</span><span class=p>,</span> <span class=k>typename</span> <span class=p>...</span><span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Func</span><span class=o>&lt;</span><span class=n>R</span><span class=p>(</span><span class=n>Args</span><span class=p>...)</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Ptrs</span><span class=o>*</span> <span class=n>func_ptrs</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>R</span><span class=p>(</span><span class=o>*</span><span class=n>call_ptr</span><span class=p>)(</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...);</span>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// needs to disallow same type, otherwise shadows the copy ctor... Also causes inifinite loops
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;!</span><span class=n>std</span><span class=o>::</span><span class=n>is_same_v</span><span class=o>&lt;</span><span class=n>Func</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>decay_t</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;&gt;&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>Func</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ptr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>std</span><span class=o>::</span><span class=n>decay_t</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>func_ptrs</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>TypePointers</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>decay_t</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;::</span><span class=n>ptrs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>call_ptr</span> <span class=o>=</span> <span class=p>[](</span><span class=kt>void</span><span class=o>*</span> <span class=n>p</span><span class=p>,</span> <span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nf>constexpr</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_void_v</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// the Args types are not deduced. This is not typical perfect-forwarding...
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>(</span><span class=n>R</span><span class=p>)(</span><span class=o>*</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>decay_t</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;*&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>))(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>decay_t</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;*&gt;</span><span class=p>(</span><span class=n>p</span><span class=p>))(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>func_ptrs</span><span class=o>-&gt;</span><span class=n>deleter_ptr</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=nf>operator</span><span class=p>()(</span><span class=n>Args</span> <span class=p>...</span><span class=n>args</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=nc>EmptyFunc</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ptr</span><span class=p>)</span> <span class=k>throw</span> <span class=n>EmptyFunc</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>call_ptr</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// copy
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Func</span><span class=p>(</span><span class=k>const</span> <span class=n>Func</span><span class=o>&amp;</span> <span class=n>f</span><span class=p>)</span> <span class=o>:</span> <span class=n>ptr</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>func_ptrs</span><span class=o>-&gt;</span><span class=n>copy_ptr</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>ptr</span><span class=p>)),</span> <span class=n>func_ptrs</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>func_ptrs</span><span class=p>),</span> <span class=n>call_ptr</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>call_ptr</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// move
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Func</span><span class=p>(</span><span class=n>Func</span><span class=o>&amp;&amp;</span> <span class=n>f</span><span class=p>)</span> <span class=o>:</span> <span class=n>ptr</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>ptr</span><span class=p>),</span> <span class=n>func_ptrs</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>func_ptrs</span><span class=p>),</span> <span class=n>call_ptr</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>call_ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span><span class=p>.</span><span class=n>ptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ans</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Func</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>func</span><span class=p>{[</span><span class=o>&amp;</span><span class=p>](</span><span class=kt>char</span> <span class=n>c</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ans</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>func2</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>func</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>func2</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Func</span><span class=o>&lt;</span><span class=kt>short</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>f3</span> <span class=p>{</span><span class=n>func2</span><span class=p>};</span> <span class=c1>// nested func
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>f3</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>It&rsquo;s a rough demo only, but you get the idea: &ldquo;remember&rdquo; how to do things later by storing function pointers.</p><p><code>ptr</code> is the stored callable.
<code>func_ptrs</code> is a group of function pointers, for managing stored callable of type <code>T</code>.
<code>call_ptr</code> records how to call the type-erased callable.</p><p>Another implementation would be an abstract base functor, which defines the virtual <code>operator()</code> with desired return type and arg types. In fact we&rsquo;ve just implemented something similar to vtables!</p><h2 id=performance>Performance</h2><p>The performance cost mainly stems from dynamic allocation and function pointer redirections.</p><h2 id=ownership>Ownership</h2><p><code>std::function</code> has ownership over the contained callable. Since C++26, there is also <code>std::function_ref</code> which stores non-owning reference to the actual callable, to avoid additional allocation.</p><h1 id=stdany><code>std::any</code></h1><p>As its name suggests, <code>std::any</code> is a <em>container</em>, that can wrap an object of any type. The type info is checked on access, so it provides type safety, compared to <code>void*</code>.</p><p>Besides that, <code>std::any</code> has clear owning semantics, while <code>void*</code> pointers have no inherent ownership.
Since the size of the object can be arbitary, it generally requires dynamic allocation (so it&rsquo;s more expensive compared to <code>std::variant</code>).</p><p>The implementation of <code>any_cast</code> requires no RTTI, since <code>std::any</code> does not need to know the exact type of the contained object, it only needs to check if the requested type matches the actual type when doing <code>any_cast</code>. This is typically achieved by storing a pointer to a static member function of a class template that is instantiated by the stored type. Comparing types is thus equivalent to comparing pointers to templated functions.</p><p>That being said, <code>std::any::type()</code> is available for obtaining runtime typeinfo of the contained object (It does require RTTI, by storing type_info). This allows flexible visitation.</p><h1 id=stdshared_ptr><code>std::shared_ptr</code></h1><p>What has <code>std::shared_ptr</code> to do with type-erasure? Well, it stores the deleter and allocator type-erased, inside the shared control block, so it&rsquo;s only templated by the object type.</p><p>In a typical implementation, <code>shared_ptr</code> holds only two pointers: one to the shared object, one to the &ldquo;control block&rdquo; that is also shared by all replicated instances. The control block will hold the pointer to the managed object (or the object itself), the deletor and the allocator (both are type-erased), and the ref-counting numbers.</p><p>A generic deleter can be supplied during construction, then stored (type-erased) inside the control block.</p><h1 id=stdvariant><code>std::variant</code></h1><p>A type-safe union. An instance of <code>std::variant</code> at any given time either holds a value of one of its alternative types, or in the case of error - no value.</p><p>As with unions, if a variant holds a value of some object type <code>T</code>, the object representation of <code>T</code> is directly within the object representation of the variant itself. Variant is not allowed to allocate additional (dynamic) memory.
It&rsquo;s usually implemented with placement new, on a buffer that is large enough to hold all kinds of elements, and has appropriate alignment. Or a tagged union.</p><h2 id=visitation>Visitation</h2><p><code>std::visit</code> works on <code>std::variant</code> by taking a generic callable that can be applied to any type held by the variant object. If the visitor function is not exhaustive, you get a compile time error.
This allows unified, type-safe operations on <code>std::variant</code> objects.</p><h3 id=implementation-1>Implementation</h3><p>A typical implementation can generate (at compile time) a table of function pointers to the resolved/instantiated function for every value type of the variant.
At runtime, the stored type index is used to select the right function.</p><p>Again, function pointers!</p><h1 id=other-sum-types>Other sum types</h1><p><code>std::optional</code>, <code>std::expected</code>, &mldr;</p><p>In general, sum types sits between actual type erasure that allows wrapping arbitary types at runtime, and fully static polymorphism.</p><h1 id=type-erased-iterator>Type-erased iterator</h1><p>E.g. <code>boost::any_range</code>, <code>any_iter</code>. Such iterators wraps any iterator that satisfy some behaviors, such as being forward iterators. They&rsquo;re especially useful at API boundaries, to provide support for abitary iterator/ranges, without compile-time monomorphization.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/c++/>C++</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Dec 26, 2023 00:00 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/compile-time-loops-in-c-/><div class=article-details><h2 class=article-title>Compile time loops in C++</h2></div></a></article><article><a href=/p/type-erasure-and-polymorphic-interface-objects/><div class=article-details><h2 class=article-title>Type erasure and polymorphic interface objects</h2></div></a></article><article><a href=/p/the-noexcept-move-constructor/><div class=article-details><h2 class=article-title>The `noexcept` move constructor</h2></div></a></article></div></div></aside><div class=disqus-container></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 Kya's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>